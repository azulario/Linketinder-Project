<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/doc/GUIA_INTEGRACAO_JDBC.txt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/doc/GUIA_INTEGRACAO_JDBC.txt" />
              <option name="originalContent" value="================================================================================&#10;    GUIA COMPLETO: INTEGRAÇÃO JDBC COM POSTGRESQL NO LINKETINDER&#10;================================================================================&#10;&#10;================================================================================&#10; TODO LIST - PROGRESSO DA IMPLEMENTAÇÃO&#10;================================================================================&#10;&#10;FASE 1: PREPARAÇÃO DO AMBIENTE&#10;-------------------------------&#10;✅ PASSO 1.1: Adicionar dependência PostgreSQL JDBC no build.gradle&#10;✅ PASSO 1.2: Configurar Spock para testes unitários no build.gradle&#10;✅ PASSO 1.3: Criar pasta 'dao' dentro de com/linketinder/&#10;✅ PASSO 1.4: Criar DatabaseConnection.groovy&#10;✅ PASSO 1.5: Criar teste unitário DatabaseConnectionSpec.groovy&#10;✅ PASSO 1.6: Testar a conexão com o banco (5 testes passando)&#10;&#10;FASE 2: ATUALIZAR AS CLASSES MODEL&#10;-----------------------------------&#10;✅ PASSO 2.1: Atualizar Candidato.groovy&#10;   ✅ Adicionar: Integer id&#10;   ✅ Adicionar: LocalDate dataDeNascimento&#10;   ✅ Adicionar: String senha&#10;   ✅ Adicionar: LocalDateTime criadoEm&#10;   ✅ Modificar construtor para calcular dataDeNascimento&#10;&#10;✅ PASSO 2.2: Atualizar Empresa.groovy&#10;   ✅ Adicionar: Integer id&#10;   ✅ Adicionar: String senha&#10;   ✅ Adicionar: LocalDateTime criadoEm&#10;&#10;⬜ PASSO 2.3: Atualizar Vaga.groovy&#10;   ⬜ Adicionar: Integer id&#10;   ⬜ Adicionar: Integer empresaId&#10;   ⬜ Adicionar: String cidade&#10;   ⬜ Adicionar: LocalDateTime criadoEm&#10;&#10;FASE 3: CRIAR OS DAOs&#10;---------------------&#10;⬜ PASSO 3.1: Criar CandidatoDAO.groovy&#10;   ⬜ Método inserir(Candidato)&#10;   ⬜ Método listar()&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método atualizar(Candidato)&#10;   ⬜ Método deletar(Integer)&#10;   ⬜ Criar teste unitário CandidatoDAOSpec.groovy&#10;&#10;⬜ PASSO 3.2: Criar EmpresaDAO.groovy&#10;   ⬜ Método inserir(Empresa)&#10;   ⬜ Método listar()&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método atualizar(Empresa)&#10;   ⬜ Método deletar(Integer)&#10;   ⬜ Criar teste unitário EmpresaDAOSpec.groovy&#10;&#10;⬜ PASSO 3.3: Criar VagaDAO.groovy&#10;   ⬜ Método inserir(Vaga)&#10;   ⬜ Método listar()&#10;   ⬜ Método listarPorEmpresa(Integer empresaId)&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método atualizar(Vaga)&#10;   ⬜ Método deletar(Integer)&#10;   ⬜ Criar teste unitário VagaDAOSpec.groovy&#10;&#10;⬜ PASSO 3.4: Criar CompetenciaDAO.groovy (opcional)&#10;   ⬜ Método inserir(String competencia)&#10;   ⬜ Método listar()&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método vincularCompetenciaCandidato(Integer candidatoId, Integer competenciaId)&#10;   ⬜ Método vincularCompetenciaVaga(Integer vagaId, Integer competenciaId)&#10;&#10;FASE 4: ADAPTAR A CLASSE DATABASE&#10;----------------------------------&#10;⬜ PASSO 4.1: Modificar Database.groovy&#10;   ⬜ Remover listas hardcoded (candidatos, empresas, vagas)&#10;   ⬜ Criar instâncias dos DAOs&#10;   ⬜ Adaptar método getCandidatos() para usar CandidatoDAO&#10;   ⬜ Adaptar método getEmpresas() para usar EmpresaDAO&#10;   ⬜ Adaptar método getVagas() para usar VagaDAO&#10;   ⬜ Adaptar método adicionarCandidato() para usar CandidatoDAO&#10;   ⬜ Adaptar método adicionarEmpresa() para usar EmpresaDAO&#10;   ⬜ Adaptar método adicionarVaga() para usar VagaDAO&#10;&#10;FASE 5: TESTAR INTEGRAÇÃO COMPLETA&#10;-----------------------------------&#10;⬜ PASSO 5.1: Testar cadastro de candidato pelo Menu&#10;⬜ PASSO 5.2: Verificar persistência no banco PostgreSQL&#10;⬜ PASSO 5.3: Testar listagem de candidatos&#10;⬜ PASSO 5.4: Testar cadastro de empresa&#10;⬜ PASSO 5.5: Testar cadastro de vaga&#10;⬜ PASSO 5.6: Testar sistema de curtidas (se aplicável)&#10;⬜ PASSO 5.7: Executar todos os testes unitários&#10;&#10;FASE 6: MELHORIAS E REFINAMENTOS&#10;---------------------------------&#10;⬜ PASSO 6.1: Adicionar validações de dados&#10;⬜ PASSO 6.2: Melhorar tratamento de erros&#10;⬜ PASSO 6.3: Implementar transações para operações complexas&#10;⬜ PASSO 6.4: Adicionar logs&#10;⬜ PASSO 6.5: Documentar código com Javadoc/Groovydoc&#10;⬜ PASSO 6.6: Atualizar README.md do projeto&#10;&#10;================================================================================&#10; PRÓXIMO PASSO: FASE 2 - ATUALIZAR AS CLASSES MODEL&#10;================================================================================&#10;&#10;Agora que a conexão com o banco está funcionando e testada, o próximo passo é&#10;atualizar as classes Model (Candidato, Empresa, Vaga) para incluir os campos&#10;necessários para integração com o banco de dados.&#10;&#10;Isso inclui adicionar IDs, senhas, timestamps, e ajustar construtores.&#10;&#10;================================================================================&#10;&#10; ÍNDICE&#10;---------&#10;1. O que é JDBC e por que usar?&#10;2. O que é DAO (Data Access Object)?&#10;3. Preparação do ambiente&#10;4. Mudanças necessárias no projeto&#10;5. Passo a passo da implementação&#10;6. Como testar a integração&#10;7. Erros comuns e soluções&#10;&#10;================================================================================&#10;1. O QUE É JDBC E POR QUE USAR?&#10;================================================================================&#10;&#10;JDBC = Java Database Connectivity&#10;&#10;É uma API (conjunto de classes e interfaces) que permite que programas Java/Groovy&#10;se conectem a bancos de dados relacionais como PostgreSQL, MySQL, Oracle, etc.&#10;&#10;ANTES (sem JDBC):&#10;-----------------&#10;• Dados ficavam apenas na memória (List&lt;Candidato&gt;, List&lt;Empresa&gt;)&#10;• Quando o programa fechava, TUDO era perdido&#10;• Impossível compartilhar dados entre execuções&#10;• Dados &quot;fictícios&quot; carregados no código&#10;&#10;DEPOIS (com JDBC):&#10;------------------&#10;• Dados salvos permanentemente no PostgreSQL&#10;• Dados persistem entre execuções do programa&#10;• Múltiplos usuários podem acessar os mesmos dados&#10;• Dados reais salvos em um banco de dados profissional&#10;&#10;================================================================================&#10;2. O QUE É DAO (DATA ACCESS OBJECT)?&#10;================================================================================&#10;&#10;DAO é um PADRÃO DE PROJETO que separa a lógica de acesso ao banco de dados&#10;da lógica de negócio da aplicação.&#10;&#10;ANALOGIA DO MUNDO REAL:&#10;-----------------------&#10;Imagine uma biblioteca:&#10;&#10;SEM DAO:&#10;Você (usuário) vai direto nas estantes, procura livros, organiza, limpa...&#10;Mistura tudo: ler livros + organizar estantes + limpar&#10;&#10;COM DAO:&#10;Você pede ao bibliotecário (DAO) que busque o livro para você.&#10;O bibliotecário sabe onde está cada livro, como organizá-los, etc.&#10;Você só precisa pedir: &quot;Quero o livro X&quot; e recebe pronto.&#10;&#10;NO CÓDIGO:&#10;----------&#10;SEM DAO (RUIM):&#10;```&#10;class Menu {&#10;    void cadastrarCandidato() {&#10;        // Coleta dados do usuário&#10;        // SQL direto aqui&#10;        Connection conn = DriverManager.getConnection(...)&#10;        PreparedStatement stmt = conn.prepareStatement(&quot;INSERT INTO...&quot;)&#10;        // Fecha conexão&#10;        // Código REPETIDO em vários lugares!&#10;    }&#10;}&#10;```&#10;&#10;COM DAO (BOM):&#10;```&#10;class Menu {&#10;    CandidatoDAO dao = new CandidatoDAO()&#10;&#10;    void cadastrarCandidato() {&#10;        Candidato candidato = coletarDados()&#10;        dao.inserir(candidato) // SIMPLES E LIMPO!&#10;    }&#10;}&#10;```&#10;&#10;VANTAGENS DO DAO:&#10;-----------------&#10;✓ Código organizado e limpo&#10;✓ Fácil de dar manutenção&#10;✓ Reutilizável (usa o mesmo DAO em vários lugares)&#10;✓ Fácil de testar&#10;✓ Se mudar de banco, só muda o DAO&#10;&#10;================================================================================&#10;3. PREPARAÇÃO DO AMBIENTE&#10;================================================================================&#10;&#10;PASSO 1: Instalar PostgreSQL&#10;-----------------------------&#10;• Baixe e instale o PostgreSQL do site oficial&#10;• Anote usuário (geralmente &quot;postgres&quot;) e senha&#10;• O banco roda na porta padrão 5432&#10;&#10;PASSO 2: Criar o banco de dados&#10;--------------------------------&#10;• Abra o terminal ou pgAdmin&#10;• Execute: CREATE DATABASE linketinder;&#10;• Execute o script LinkeTinder.sql que já está no projeto&#10;  (Ele cria todas as tabelas, índices e insere dados de exemplo)&#10;&#10;PASSO 3: Adicionar dependência JDBC no projeto&#10;-----------------------------------------------&#10;• Editar arquivo build.gradle&#10;• Adicionar: implementation 'org.postgresql:postgresql:42.7.1'&#10;• Executar: gradle build (para baixar a biblioteca)&#10;&#10;================================================================================&#10;4. MUDANÇAS NECESSÁRIAS NO PROJETO&#10;================================================================================&#10;&#10;O projeto atual tem esta estrutura:&#10;&#10;ANTES:&#10;------&#10;Main.groovy&#10;  ↓&#10;Menu.groovy → Database.groovy (dados em memória)&#10;  ↓              ↓&#10;Candidato    Empresa    Vaga&#10;(models)&#10;&#10;DEPOIS:&#10;-------&#10;Main.groovy&#10;  ↓&#10;Menu.groovy → Database.groovy → DAOs → PostgreSQL&#10;  ↓                                ↓&#10;Candidato    Empresa    Vaga    CandidatoDAO&#10;(models)                        EmpresaDAO&#10;                                VagaDAO&#10;                                DatabaseConnection&#10;&#10;NOVOS COMPONENTES:&#10;------------------&#10;&#10;1. DatabaseConnection.groovy&#10;   • Responsável por conectar ao PostgreSQL&#10;   • Abre e fecha conexões com o banco&#10;&#10;2. CandidatoDAO.groovy&#10;   • Gerencia operações de Candidato no banco&#10;   • Métodos: inserir(), listar(), buscarPorId(), atualizar(), deletar()&#10;&#10;3. EmpresaDAO.groovy&#10;   • Gerencia operações de Empresa no banco&#10;   • Métodos: inserir(), listar(), buscarPorId(), atualizar(), deletar()&#10;&#10;4. VagaDAO.groovy&#10;   • Gerencia operações de Vaga no banco&#10;   • Métodos: inserir(), listar(), atualizar(), deletar()&#10;&#10;5. CompetenciaDAO.groovy (opcional mas recomendado)&#10;   • Gerencia operações de Competências no banco&#10;&#10;MUDANÇAS NOS MODELS:&#10;--------------------&#10;&#10;Candidato.groovy&#10;• Adicionar propriedade: Integer id&#10;• Adicionar propriedade: LocalDate dataDeNascimento&#10;• Adicionar propriedade: String senha&#10;• Adicionar propriedade: LocalDateTime criadoEm&#10;• Modificar construtor para calcular dataDeNascimento a partir da idade&#10;&#10;Empresa.groovy&#10;• Adicionar propriedade: Integer id&#10;• Adicionar propriedade: String senha&#10;• Adicionar propriedade: LocalDateTime criadoEm&#10;&#10;Vaga.groovy&#10;• Adicionar propriedade: Integer id&#10;• Adicionar propriedade: Integer empresaId&#10;• Adicionar propriedade: String cidade&#10;• Adicionar propriedade: LocalDateTime criadoEm&#10;• Renomear 'titulo' se necessário para 'nomeVaga'&#10;&#10;================================================================================&#10;5. PASSO A PASSO DA IMPLEMENTAÇÃO&#10;================================================================================&#10;&#10;FASE 1: CRIAR A CONEXÃO COM O BANCO&#10;------------------------------------&#10;&#10;□ PASSO 1.1: Criar pasta 'dao' dentro de com/linketinder/&#10;   Caminho: src/main/groovy/com/linketinder/dao/&#10;&#10;□ PASSO 1.2: Criar DatabaseConnection.groovy&#10;   Local: src/main/groovy/com/linketinder/database/DatabaseConnection.groovy&#10;&#10;   O que faz:&#10;   • Guarda as informações de conexão (URL, usuário, senha)&#10;   • Método getConnection() → abre uma conexão com o banco&#10;   • Método closeConnection() → fecha a conexão&#10;&#10;   IMPORTANTE: Trocar &quot;sua_senha&quot; pela senha real do PostgreSQL!&#10;&#10;□ PASSO 1.3: Testar a conexão&#10;   • Criar um arquivo de teste simples&#10;   • Tentar conectar e desconectar&#10;   • Se funcionar, está pronto!&#10;&#10;FASE 2: ATUALIZAR AS CLASSES MODEL&#10;-----------------------------------&#10;&#10;□ PASSO 2.1: Atualizar Candidato.groovy&#10;   Adicionar:&#10;   ```&#10;   Integer id&#10;   LocalDate dataDeNascimento&#10;   String senha&#10;   LocalDateTime criadoEm&#10;   ```&#10;&#10;   Modificar construtor para calcular dataDeNascimento:&#10;   ```&#10;   this.dataDeNascimento = LocalDate.now().minusYears(idade)&#10;   ```&#10;&#10;□ PASSO 2.2: Atualizar Empresa.groovy&#10;   Adicionar:&#10;   ```&#10;   Integer id&#10;   String senha&#10;   LocalDateTime criadoEm&#10;   ```&#10;&#10;□ PASSO 2.3: Atualizar Vaga.groovy&#10;   Adicionar:&#10;   ```&#10;   Integer id&#10;   Integer empresaId&#10;   String cidade&#10;   LocalDateTime criadoEm&#10;   ```&#10;&#10;FASE 3: CRIAR OS DAOs&#10;---------------------&#10;&#10;□ PASSO 3.1: Criar CandidatoDAO.groovy&#10;&#10;   Estrutura básica:&#10;   ```&#10;   class CandidatoDAO {&#10;       void inserir(Candidato candidato) {&#10;           // 1. Abre conexão&#10;           // 2. Prepara SQL INSERT&#10;           // 3. Preenche parâmetros (?, ?, ?)&#10;           // 4. Executa&#10;           // 5. Pega o ID gerado&#10;           // 6. Fecha conexão&#10;       }&#10;&#10;       List&lt;Candidato&gt; listar() {&#10;           // 1. Abre conexão&#10;           // 2. Executa SELECT&#10;           // 3. Percorre ResultSet&#10;           // 4. Cria objetos Candidato&#10;           // 5. Fecha conexão&#10;           // 6. Retorna lista&#10;       }&#10;   }&#10;   ```&#10;&#10;   CONCEITOS IMPORTANTES:&#10;&#10;   • Connection: Representa a conexão com o banco&#10;   • PreparedStatement: Prepara o comando SQL de forma segura&#10;   • ResultSet: Resultado da consulta (como uma tabela)&#10;   • try-catch-finally: Garante que a conexão será fechada&#10;&#10;   EXEMPLO DE INSERT:&#10;   ```&#10;   String sql = &quot;INSERT INTO candidatos (nome, email) VALUES (?, ?)&quot;&#10;   PreparedStatement stmt = conn.prepareStatement(sql)&#10;   stmt.setString(1, candidato.nome)    // primeiro ?&#10;   stmt.setString(2, candidato.email)   // segundo ?&#10;   stmt.executeUpdate()&#10;   ```&#10;&#10;   EXEMPLO DE SELECT:&#10;   ```&#10;   String sql = &quot;SELECT * FROM candidatos&quot;&#10;   Statement stmt = conn.createStatement()&#10;   ResultSet rs = stmt.executeQuery(sql)&#10;&#10;   while (rs.next()) {&#10;       String nome = rs.getString(&quot;nome&quot;)&#10;       String email = rs.getString(&quot;email&quot;)&#10;       // Criar objeto Candidato&#10;   }&#10;   ```&#10;&#10;□ PASSO 3.2: Criar EmpresaDAO.groovy&#10;   Similar ao CandidatoDAO, mas para a tabela 'empresas'&#10;&#10;□ PASSO 3.3: Criar VagaDAO.groovy&#10;   Similar, mas para a tabela 'vagas'&#10;&#10;   ATENÇÃO: Vaga tem relacionamento N:N com Competências!&#10;   Precisa inserir também na tabela 'competencias_vagas'&#10;&#10;□ PASSO 3.4: Criar CompetenciaDAO.groovy (opcional)&#10;   Para gerenciar competências de forma independente&#10;&#10;FASE 4: ADAPTAR A CLASSE DATABASE&#10;----------------------------------&#10;&#10;□ PASSO 4.1: Modificar Database.groovy&#10;&#10;   ANTES (dados em memória):&#10;   ```&#10;   class Database {&#10;       List&lt;Candidato&gt; candidatos = []&#10;&#10;       Database() {&#10;           carregarCandidatos() // hardcoded&#10;       }&#10;   }&#10;   ```&#10;&#10;   DEPOIS (dados do PostgreSQL):&#10;   ```&#10;   class Database {&#10;       private CandidatoDAO candidatoDAO = new CandidatoDAO()&#10;       private EmpresaDAO empresaDAO = new EmpresaDAO()&#10;       private VagaDAO vagaDAO = new VagaDAO()&#10;&#10;       List&lt;Candidato&gt; getCandidatos() {&#10;           return candidatoDAO.listar()&#10;       }&#10;&#10;       void adicionarCandidato(Candidato candidato) {&#10;           candidatoDAO.inserir(candidato)&#10;       }&#10;   }&#10;   ```&#10;&#10;   VANTAGEM: Não precisa mudar nada no Menu.groovy!&#10;   O Menu continua chamando database.candidatos ou database.adicionarCandidato()&#10;&#10;FASE 5: TESTAR E AJUSTAR&#10;-------------------------&#10;&#10;□ PASSO 5.1: Testar cadastro de candidato&#10;   • Executar o programa&#10;   • Cadastrar um novo candidato pelo menu&#10;   • Verificar no banco se foi salvo:&#10;     SELECT * FROM candidatos;&#10;&#10;□ PASSO 5.2: Testar listagem&#10;   • Listar candidatos pelo menu&#10;   • Verificar se mostra os do banco&#10;&#10;□ PASSO 5.3: Testar cadastro de empresa&#10;   Similar ao candidato&#10;&#10;□ PASSO 5.4: Testar vagas&#10;   • Cadastrar vaga vinculada a uma empresa existente&#10;   • Verificar competências associadas&#10;&#10;================================================================================&#10;6. COMO TESTAR A INTEGRAÇÃO&#10;================================================================================&#10;&#10;TESTE 1: Conexão básica&#10;------------------------&#10;Criar arquivo TesteConexao.groovy:&#10;```&#10;Connection conn = DatabaseConnection.getConnection()&#10;println &quot;Conectado! Versão: &quot; + conn.metaData.databaseProductVersion&#10;DatabaseConnection.closeConnection(conn)&#10;```&#10;&#10;TESTE 2: Inserir e buscar candidato&#10;------------------------------------&#10;```&#10;CandidatoDAO dao = new CandidatoDAO()&#10;Candidato c = new Candidato(&quot;Teste&quot;, &quot;teste@email.com&quot;, ...)&#10;dao.inserir(c)&#10;List&lt;Candidato&gt; todos = dao.listar()&#10;todos.each { println it.nome }&#10;```&#10;&#10;TESTE 3: Programa completo&#10;---------------------------&#10;• Executar Main.groovy&#10;• Cadastrar novo candidato&#10;• Fechar o programa&#10;• Executar novamente&#10;• Verificar se o candidato ainda está lá (persistência!)&#10;&#10;VERIFICAÇÃO NO BANCO:&#10;---------------------&#10;Abrir terminal PostgreSQL ou pgAdmin:&#10;```&#10;psql -U postgres -d linketinder&#10;&#10;SELECT * FROM candidatos;&#10;SELECT * FROM empresas;&#10;SELECT * FROM vagas;&#10;SELECT * FROM competencias;&#10;```&#10;&#10;================================================================================&#10;7. ERROS COMUNS E SOLUÇÕES&#10;================================================================================&#10;&#10;ERRO 1: &quot;No suitable driver found&quot;&#10;-----------------------------------&#10;CAUSA: Biblioteca PostgreSQL JDBC não foi baixada&#10;SOLUÇÃO:&#10;• Verificar build.gradle tem: implementation 'org.postgresql:postgresql:42.7.1'&#10;• Executar: gradle clean build&#10;• Recarregar projeto na IDE&#10;&#10;ERRO 2: &quot;Connection refused&quot;&#10;-----------------------------&#10;CAUSA: PostgreSQL não está rodando OU porta/host errado&#10;SOLUÇÃO:&#10;• Verificar se PostgreSQL está rodando&#10;• No Mac: brew services list&#10;• Verificar URL: jdbc:postgresql://localhost:5432/linketinder&#10;• Verificar firewall&#10;&#10;ERRO 3: &quot;Password authentication failed&quot;&#10;-----------------------------------------&#10;CAUSA: Senha incorreta em DatabaseConnection&#10;SOLUÇÃO:&#10;• Confirmar senha do usuário postgres&#10;• Editar DatabaseConnection.groovy&#10;• Trocar PASSWORD = &quot;sua_senha&quot; pela senha correta&#10;&#10;ERRO 4: &quot;Relation 'candidatos' does not exist&quot;&#10;-----------------------------------------------&#10;CAUSA: Tabelas não foram criadas no banco&#10;SOLUÇÃO:&#10;• Executar o script LinkeTinder.sql no PostgreSQL&#10;• Verificar se conectou no banco correto: \c linketinder&#10;&#10;ERRO 5: &quot;Column 'id' is null&quot;&#10;------------------------------&#10;CAUSA: Tentou salvar objeto sem ID ou campo obrigatório faltando&#10;SOLUÇÃO:&#10;• ID deve ser gerado pelo banco (SERIAL)&#10;• Usar Statement.RETURN_GENERATED_KEYS para pegar ID&#10;• Verificar todos os campos obrigatórios do INSERT&#10;&#10;ERRO 6: NullPointerException ao listar&#10;---------------------------------------&#10;CAUSA: Tentou acessar propriedade de objeto null&#10;SOLUÇÃO:&#10;• Verificar se ResultSet tem dados: if (rs.next())&#10;• Verificar se lista está vazia antes de acessar: if (!lista.isEmpty())&#10;• Adicionar verificações null&#10;&#10;ERRO 7: &quot;Too many connections&quot;&#10;-------------------------------&#10;CAUSA: Não fechou conexões anteriores&#10;SOLUÇÃO:&#10;• SEMPRE usar try-finally&#10;• SEMPRE chamar DatabaseConnection.closeConnection(conn)&#10;• Considerar usar Connection Pool no futuro&#10;&#10;================================================================================&#10;RESUMO DAS MUDANÇAS&#10;================================================================================&#10;&#10;ARQUIVOS NOVOS:&#10;✓ src/main/groovy/com/linketinder/database/DatabaseConnection.groovy&#10;✓ src/main/groovy/com/linketinder/dao/CandidatoDAO.groovy&#10;✓ src/main/groovy/com/linketinder/dao/EmpresaDAO.groovy&#10;✓ src/main/groovy/com/linketinder/dao/VagaDAO.groovy&#10;✓ src/main/groovy/com/linketinder/dao/CompetenciaDAO.groovy (opcional)&#10;&#10;ARQUIVOS MODIFICADOS:&#10;✓ build.gradle (adicionar dependência PostgreSQL)&#10;✓ src/main/groovy/com/linketinder/model/Candidato.groovy&#10;✓ src/main/groovy/com/linketinder/model/Empresa.groovy&#10;✓ src/main/groovy/com/linketinder/model/Vaga.groovy&#10;✓ src/main/groovy/com/linketinder/database/Database.groovy&#10;&#10;ARQUIVOS NÃO MODIFICADOS:&#10;✓ src/main/groovy/com/linketinder/view/Menu.groovy (mantém a mesma interface)&#10;✓ src/main/groovy/com/linketinder/Main.groovy (mantém o mesmo)&#10;✓ Testes unitários (por enquanto)&#10;&#10;================================================================================&#10;PRÓXIMOS PASSOS (APÓS JDBC FUNCIONAR)&#10;================================================================================&#10;&#10;1. Implementar sistema de curtidas no banco (tabela 'curtidas')&#10;2. Criar testes unitários com Spock para os DAOs&#10;3. Adicionar validações de dados&#10;4. Implementar busca por competências&#10;5. Melhorar tratamento de erros&#10;6. Adicionar logs&#10;7. Considerar usar Connection Pool para performance&#10;&#10;================================================================================&#10;GLOSSÁRIO DE TERMOS&#10;================================================================================&#10;&#10;JDBC: Java Database Connectivity - API para conectar Java com bancos de dados&#10;&#10;DAO: Data Access Object - Padrão que separa acesso a dados da lógica de negócio&#10;&#10;Connection: Objeto que representa conexão ativa com o banco de dados&#10;&#10;PreparedStatement: Comando SQL preparado de forma segura (previne SQL Injection)&#10;&#10;ResultSet: Conjunto de resultados de uma query SELECT (como uma tabela)&#10;&#10;SQL Injection: Ataque de segurança onde código malicioso é inserido via input&#10;&#10;CRUD: Create, Read, Update, Delete - Operações básicas em banco de dados&#10;&#10;ORM: Object-Relational Mapping - Mapeia objetos para tabelas (ex: Hibernate)&#10;&#10;Transaction: Conjunto de operações que devem todas ter sucesso ou falhar juntas&#10;&#10;Foreign Key: Chave estrangeira - liga uma tabela a outra&#10;&#10;Primary Key: Chave primária - identificador único de cada linha&#10;&#10;SERIAL: Tipo PostgreSQL que gera IDs automaticamente (auto-increment)&#10;&#10;================================================================================&#10;DICAS FINAIS&#10;================================================================================&#10;&#10;1. SEMPRE feche as conexões! Use try-finally ou try-with-resources&#10;&#10;2. Use PreparedStatement, nunca concatene strings SQL (segurança!)&#10;&#10;3. Trate exceções de forma apropriada, não apenas printStackTrace()&#10;&#10;4. Faça backup do banco antes de testar operações de DELETE&#10;&#10;5. Use transações para operações que precisam ser atômicas&#10;&#10;6. Teste cada DAO isoladamente antes de integrar tudo&#10;&#10;7. Mantenha a senha do banco em arquivo de configuração (não no código!)&#10;&#10;8. Use logs para debug (System.out.println é temporário)&#10;&#10;9. Leia a documentação do PostgreSQL JDBC Driver&#10;&#10;10. Peça ajuda quando travar! É normal ter dúvidas no início&#10;&#10;================================================================================&#10;BOA SORTE COM A INTEGRAÇÃO JDBC!&#10;================================================================================&#10;" />
              <option name="updatedContent" value="================================================================================&#10;    GUIA COMPLETO: INTEGRAÇÃO JDBC COM POSTGRESQL NO LINKETINDER&#10;================================================================================&#10;&#10;================================================================================&#10; TODO LIST - PROGRESSO DA IMPLEMENTAÇÃO&#10;================================================================================&#10;&#10;FASE 1: PREPARAÇÃO DO AMBIENTE&#10;-------------------------------&#10;✅ PASSO 1.1: Adicionar dependência PostgreSQL JDBC no build.gradle&#10;✅ PASSO 1.2: Configurar Spock para testes unitários no build.gradle&#10;✅ PASSO 1.3: Criar pasta 'dao' dentro de com/linketinder/&#10;✅ PASSO 1.4: Criar DatabaseConnection.groovy&#10;✅ PASSO 1.5: Criar teste unitário DatabaseConnectionSpec.groovy&#10;✅ PASSO 1.6: Testar a conexão com o banco (5 testes passando)&#10;&#10;FASE 2: ATUALIZAR AS CLASSES MODEL&#10;-----------------------------------&#10;✅ PASSO 2.1: Atualizar Candidato.groovy&#10;   ✅ Adicionar: Integer id&#10;   ✅ Adicionar: LocalDate dataDeNascimento&#10;   ✅ Adicionar: String senha&#10;   ✅ Adicionar: LocalDateTime criadoEm&#10;   ✅ Modificar construtor para calcular dataDeNascimento&#10;&#10;✅ PASSO 2.2: Atualizar Empresa.groovy&#10;   ✅ Adicionar: Integer id&#10;   ✅ Adicionar: String senha&#10;   ✅ Adicionar: LocalDateTime criadoEm&#10;&#10;⬜ PASSO 2.3: Atualizar Vaga.groovy&#10;   ⬜ Adicionar: Integer id&#10;   ⬜ Adicionar: Integer empresaId&#10;   ⬜ Adicionar: String cidade&#10;   ⬜ Adicionar: LocalDateTime criadoEm&#10;&#10;FASE 3: CRIAR OS DAOs&#10;---------------------&#10;⬜ PASSO 3.1: Criar CandidatoDAO.groovy&#10;   ⬜ Método inserir(Candidato)&#10;   ⬜ Método listar()&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método atualizar(Candidato)&#10;   ⬜ Método deletar(Integer)&#10;   ⬜ Criar teste unitário CandidatoDAOSpec.groovy&#10;&#10;⬜ PASSO 3.2: Criar EmpresaDAO.groovy&#10;   ⬜ Método inserir(Empresa)&#10;   ⬜ Método listar()&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método atualizar(Empresa)&#10;   ⬜ Método deletar(Integer)&#10;   ⬜ Criar teste unitário EmpresaDAOSpec.groovy&#10;&#10;⬜ PASSO 3.3: Criar VagaDAO.groovy&#10;   ⬜ Método inserir(Vaga)&#10;   ⬜ Método listar()&#10;   ⬜ Método listarPorEmpresa(Integer empresaId)&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método atualizar(Vaga)&#10;   ⬜ Método deletar(Integer)&#10;   ⬜ Criar teste unitário VagaDAOSpec.groovy&#10;&#10;⬜ PASSO 3.4: Criar CompetenciaDAO.groovy (opcional)&#10;   ⬜ Método inserir(String competencia)&#10;   ⬜ Método listar()&#10;   ⬜ Método buscarPorId(Integer)&#10;   ⬜ Método vincularCompetenciaCandidato(Integer candidatoId, Integer competenciaId)&#10;   ⬜ Método vincularCompetenciaVaga(Integer vagaId, Integer competenciaId)&#10;&#10;FASE 4: ADAPTAR A CLASSE DATABASE&#10;----------------------------------&#10;⬜ PASSO 4.1: Modificar Database.groovy&#10;   ⬜ Remover listas hardcoded (candidatos, empresas, vagas)&#10;   ⬜ Criar instâncias dos DAOs&#10;   ⬜ Adaptar método getCandidatos() para usar CandidatoDAO&#10;   ⬜ Adaptar método getEmpresas() para usar EmpresaDAO&#10;   ⬜ Adaptar método getVagas() para usar VagaDAO&#10;   ⬜ Adaptar método adicionarCandidato() para usar CandidatoDAO&#10;   ⬜ Adaptar método adicionarEmpresa() para usar EmpresaDAO&#10;   ⬜ Adaptar método adicionarVaga() para usar VagaDAO&#10;&#10;FASE 5: TESTAR INTEGRAÇÃO COMPLETA&#10;-----------------------------------&#10;⬜ PASSO 5.1: Testar cadastro de candidato pelo Menu&#10;⬜ PASSO 5.2: Verificar persistência no banco PostgreSQL&#10;⬜ PASSO 5.3: Testar listagem de candidatos&#10;⬜ PASSO 5.4: Testar cadastro de empresa&#10;⬜ PASSO 5.5: Testar cadastro de vaga&#10;⬜ PASSO 5.6: Testar sistema de curtidas (se aplicável)&#10;⬜ PASSO 5.7: Executar todos os testes unitários&#10;&#10;FASE 6: MELHORIAS E REFINAMENTOS&#10;---------------------------------&#10;⬜ PASSO 6.1: Adicionar validações de dados&#10;⬜ PASSO 6.2: Melhorar tratamento de erros&#10;⬜ PASSO 6.3: Implementar transações para operações complexas&#10;⬜ PASSO 6.4: Adicionar logs&#10;⬜ PASSO 6.5: Documentar código com Javadoc/Groovydoc&#10;⬜ PASSO 6.6: Atualizar README.md do projeto&#10;&#10;================================================================================&#10; PRÓXIMO PASSO: FASE 2 - ATUALIZAR AS CLASSES MODEL&#10;================================================================================&#10;&#10;Agora que a conexão com o banco está funcionando e testada, o próximo passo é&#10;atualizar as classes Model (Candidato, Empresa, Vaga) para incluir os campos&#10;necessários para integração com o banco de dados.&#10;&#10;Isso inclui adicionar IDs, senhas, timestamps, e ajustar construtores.&#10;&#10;================================================================================&#10;&#10; ÍNDICE&#10;---------&#10;1. O que é JDBC e por que usar?&#10;2. O que é DAO (Data Access Object)?&#10;3. Preparação do ambiente&#10;4. Mudanças necessárias no projeto&#10;5. Passo a passo da implementação&#10;6. Como testar a integração&#10;7. Erros comuns e soluções&#10;&#10;================================================================================&#10;1. O QUE É JDBC E POR QUE USAR?&#10;================================================================================&#10;&#10;JDBC = Java Database Connectivity&#10;&#10;É uma API (conjunto de classes e interfaces) que permite que programas Java/Groovy&#10;se conectem a bancos de dados relacionais como PostgreSQL, MySQL, Oracle, etc.&#10;&#10;ANTES (sem JDBC):&#10;-----------------&#10;• Dados ficavam apenas na memória (List&lt;Candidato&gt;, List&lt;Empresa&gt;)&#10;• Quando o programa fechava, TUDO era perdido&#10;• Impossível compartilhar dados entre execuções&#10;• Dados &quot;fictícios&quot; carregados no código&#10;&#10;DEPOIS (com JDBC):&#10;------------------&#10;• Dados salvos permanentemente no PostgreSQL&#10;• Dados persistem entre execuções do programa&#10;• Múltiplos usuários podem acessar os mesmos dados&#10;• Dados reais salvos em um banco de dados profissional&#10;&#10;================================================================================&#10;2. O QUE É DAO (DATA ACCESS OBJECT)?&#10;================================================================================&#10;&#10;DAO é um PADRÃO DE PROJETO que separa a lógica de acesso ao banco de dados&#10;da lógica de negócio da aplicação.&#10;&#10;ANALOGIA DO MUNDO REAL:&#10;-----------------------&#10;Imagine uma biblioteca:&#10;&#10;SEM DAO:&#10;Você (usuário) vai direto nas estantes, procura livros, organiza, limpa...&#10;Mistura tudo: ler livros + organizar estantes + limpar&#10;&#10;COM DAO:&#10;Você pede ao bibliotecário (DAO) que busque o livro para você.&#10;O bibliotecário sabe onde está cada livro, como organizá-los, etc.&#10;Você só precisa pedir: &quot;Quero o livro X&quot; e recebe pronto.&#10;&#10;NO CÓDIGO:&#10;----------&#10;SEM DAO (RUIM):&#10;```&#10;class Menu {&#10;    void cadastrarCandidato() {&#10;        // Coleta dados do usuário&#10;        // SQL direto aqui&#10;        Connection conn = DriverManager.getConnection(...)&#10;        PreparedStatement stmt = conn.prepareStatement(&quot;INSERT INTO...&quot;)&#10;        // Fecha conexão&#10;        // Código REPETIDO em vários lugares!&#10;    }&#10;}&#10;```&#10;&#10;COM DAO (BOM):&#10;```&#10;class Menu {&#10;    CandidatoDAO dao = new CandidatoDAO()&#10;&#10;    void cadastrarCandidato() {&#10;        Candidato candidato = coletarDados()&#10;        dao.inserir(candidato) // SIMPLES E LIMPO!&#10;    }&#10;}&#10;```&#10;&#10;VANTAGENS DO DAO:&#10;-----------------&#10;✓ Código organizado e limpo&#10;✓ Fácil de dar manutenção&#10;✓ Reutilizável (usa o mesmo DAO em vários lugares)&#10;✓ Fácil de testar&#10;✓ Se mudar de banco, só muda o DAO&#10;&#10;================================================================================&#10;3. PREPARAÇÃO DO AMBIENTE&#10;================================================================================&#10;&#10;PASSO 1: Instalar PostgreSQL&#10;-----------------------------&#10;• Baixe e instale o PostgreSQL do site oficial&#10;• Anote usuário (geralmente &quot;postgres&quot;) e senha&#10;• O banco roda na porta padrão 5432&#10;&#10;PASSO 2: Criar o banco de dados&#10;--------------------------------&#10;• Abra o terminal ou pgAdmin&#10;• Execute: CREATE DATABASE linketinder;&#10;• Execute o script LinkeTinder.sql que já está no projeto&#10;  (Ele cria todas as tabelas, índices e insere dados de exemplo)&#10;&#10;PASSO 3: Adicionar dependência JDBC no projeto&#10;-----------------------------------------------&#10;• Editar arquivo build.gradle&#10;• Adicionar: implementation 'org.postgresql:postgresql:42.7.1'&#10;• Executar: gradle build (para baixar a biblioteca)&#10;&#10;================================================================================&#10;4. MUDANÇAS NECESSÁRIAS NO PROJETO&#10;================================================================================&#10;&#10;O projeto atual tem esta estrutura:&#10;&#10;ANTES:&#10;------&#10;Main.groovy&#10;  ↓&#10;Menu.groovy → Database.groovy (dados em memória)&#10;  ↓              ↓&#10;Candidato    Empresa    Vaga&#10;(models)&#10;&#10;DEPOIS:&#10;-------&#10;Main.groovy&#10;  ↓&#10;Menu.groovy → Database.groovy → DAOs → PostgreSQL&#10;  ↓                                ↓&#10;Candidato    Empresa    Vaga    CandidatoDAO&#10;(models)                        EmpresaDAO&#10;                                VagaDAO&#10;                                DatabaseConnection&#10;&#10;NOVOS COMPONENTES:&#10;------------------&#10;&#10;1. DatabaseConnection.groovy&#10;   • Responsável por conectar ao PostgreSQL&#10;   • Abre e fecha conexões com o banco&#10;&#10;2. CandidatoDAO.groovy&#10;   • Gerencia operações de Candidato no banco&#10;   • Métodos: inserir(), listar(), buscarPorId(), atualizar(), deletar()&#10;&#10;3. EmpresaDAO.groovy&#10;   • Gerencia operações de Empresa no banco&#10;   • Métodos: inserir(), listar(), buscarPorId(), atualizar(), deletar()&#10;&#10;4. VagaDAO.groovy&#10;   • Gerencia operações de Vaga no banco&#10;   • Métodos: inserir(), listar(), atualizar(), deletar()&#10;&#10;5. CompetenciaDAO.groovy (opcional mas recomendado)&#10;   • Gerencia operações de Competências no banco&#10;&#10;MUDANÇAS NOS MODELS:&#10;--------------------&#10;&#10;Candidato.groovy&#10;• Adicionar propriedade: Integer id&#10;• Adicionar propriedade: LocalDate dataDeNascimento&#10;• Adicionar propriedade: String senha&#10;• Adicionar propriedade: LocalDateTime criadoEm&#10;• Modificar construtor para calcular dataDeNascimento a partir da idade&#10;&#10;Empresa.groovy&#10;• Adicionar propriedade: Integer id&#10;• Adicionar propriedade: String senha&#10;• Adicionar propriedade: LocalDateTime criadoEm&#10;&#10;Vaga.groovy&#10;• Adicionar propriedade: Integer id&#10;• Adicionar propriedade: Integer empresaId&#10;• Adicionar propriedade: String cidade&#10;• Adicionar propriedade: LocalDateTime criadoEm&#10;• Renomear 'titulo' se necessário para 'nomeVaga'&#10;&#10;================================================================================&#10;5. PASSO A PASSO DA IMPLEMENTAÇÃO&#10;================================================================================&#10;&#10;FASE 1: CRIAR A CONEXÃO COM O BANCO&#10;------------------------------------&#10;&#10;□ PASSO 1.1: Criar pasta 'dao' dentro de com/linketinder/&#10;   Caminho: src/main/groovy/com/linketinder/dao/&#10;&#10;□ PASSO 1.2: Criar DatabaseConnection.groovy&#10;   Local: src/main/groovy/com/linketinder/database/DatabaseConnection.groovy&#10;&#10;   O que faz:&#10;   • Guarda as informações de conexão (URL, usuário, senha)&#10;   • Método getConnection() → abre uma conexão com o banco&#10;   • Método closeConnection() → fecha a conexão&#10;&#10;   IMPORTANTE: Trocar &quot;sua_senha&quot; pela senha real do PostgreSQL!&#10;&#10;□ PASSO 1.3: Testar a conexão&#10;   • Criar um arquivo de teste simples&#10;   • Tentar conectar e desconectar&#10;   • Se funcionar, está pronto!&#10;&#10;FASE 2: ATUALIZAR AS CLASSES MODEL&#10;-----------------------------------&#10;&#10;□ PASSO 2.1: Atualizar Candidato.groovy&#10;   Adicionar:&#10;   ```&#10;   Integer id&#10;   LocalDate dataDeNascimento&#10;   String senha&#10;   LocalDateTime criadoEm&#10;   ```&#10;&#10;   Modificar construtor para calcular dataDeNascimento:&#10;   ```&#10;   this.dataDeNascimento = LocalDate.now().minusYears(idade)&#10;   ```&#10;&#10;□ PASSO 2.2: Atualizar Empresa.groovy&#10;   Adicionar:&#10;   ```&#10;   Integer id&#10;   String senha&#10;   LocalDateTime criadoEm&#10;   ```&#10;&#10;□ PASSO 2.3: Atualizar Vaga.groovy&#10;   Adicionar:&#10;   ```&#10;   Integer id&#10;   Integer empresaId&#10;   String cidade&#10;   LocalDateTime criadoEm&#10;   ```&#10;&#10;FASE 3: CRIAR OS DAOs&#10;---------------------&#10;&#10;□ PASSO 3.1: Criar CandidatoDAO.groovy&#10;&#10;   Estrutura básica:&#10;   ```&#10;   class CandidatoDAO {&#10;       void inserir(Candidato candidato) {&#10;           // 1. Abre conexão&#10;           // 2. Prepara SQL INSERT&#10;           // 3. Preenche parâmetros (?, ?, ?)&#10;           // 4. Executa&#10;           // 5. Pega o ID gerado&#10;           // 6. Fecha conexão&#10;       }&#10;&#10;       List&lt;Candidato&gt; listar() {&#10;           // 1. Abre conexão&#10;           // 2. Executa SELECT&#10;           // 3. Percorre ResultSet&#10;           // 4. Cria objetos Candidato&#10;           // 5. Fecha conexão&#10;           // 6. Retorna lista&#10;       }&#10;   }&#10;   ```&#10;&#10;   CONCEITOS IMPORTANTES:&#10;&#10;   • Connection: Representa a conexão com o banco&#10;   • PreparedStatement: Prepara o comando SQL de forma segura&#10;   • ResultSet: Resultado da consulta (como uma tabela)&#10;   • try-catch-finally: Garante que a conexão será fechada&#10;&#10;   EXEMPLO DE INSERT:&#10;   ```&#10;   String sql = &quot;INSERT INTO candidatos (nome, email) VALUES (?, ?)&quot;&#10;   PreparedStatement stmt = conn.prepareStatement(sql)&#10;   stmt.setString(1, candidato.nome)    // primeiro ?&#10;   stmt.setString(2, candidato.email)   // segundo ?&#10;   stmt.executeUpdate()&#10;   ```&#10;&#10;   EXEMPLO DE SELECT:&#10;   ```&#10;   String sql = &quot;SELECT * FROM candidatos&quot;&#10;   Statement stmt = conn.createStatement()&#10;   ResultSet rs = stmt.executeQuery(sql)&#10;&#10;   while (rs.next()) {&#10;       String nome = rs.getString(&quot;nome&quot;)&#10;       String email = rs.getString(&quot;email&quot;)&#10;       // Criar objeto Candidato&#10;   }&#10;   ```&#10;&#10;□ PASSO 3.2: Criar EmpresaDAO.groovy&#10;   Similar ao CandidatoDAO, mas para a tabela 'empresas'&#10;&#10;□ PASSO 3.3: Criar VagaDAO.groovy&#10;   Similar, mas para a tabela 'vagas'&#10;&#10;   ATENÇÃO: Vaga tem relacionamento N:N com Competências!&#10;   Precisa inserir também na tabela 'competencias_vagas'&#10;&#10;□ PASSO 3.4: Criar CompetenciaDAO.groovy (opcional)&#10;   Para gerenciar competências de forma independente&#10;&#10;FASE 4: ADAPTAR A CLASSE DATABASE&#10;----------------------------------&#10;&#10;□ PASSO 4.1: Modificar Database.groovy&#10;&#10;   ANTES (dados em memória):&#10;   ```&#10;   class Database {&#10;       List&lt;Candidato&gt; candidatos = []&#10;&#10;       Database() {&#10;           carregarCandidatos() // hardcoded&#10;       }&#10;   }&#10;   ```&#10;&#10;   DEPOIS (dados do PostgreSQL):&#10;   ```&#10;   class Database {&#10;       private CandidatoDAO candidatoDAO = new CandidatoDAO()&#10;       private EmpresaDAO empresaDAO = new EmpresaDAO()&#10;       private VagaDAO vagaDAO = new VagaDAO()&#10;&#10;       List&lt;Candidato&gt; getCandidatos() {&#10;           return candidatoDAO.listar()&#10;       }&#10;&#10;       void adicionarCandidato(Candidato candidato) {&#10;           candidatoDAO.inserir(candidato)&#10;       }&#10;   }&#10;   ```&#10;&#10;   VANTAGEM: Não precisa mudar nada no Menu.groovy!&#10;   O Menu continua chamando database.candidatos ou database.adicionarCandidato()&#10;&#10;FASE 5: TESTAR E AJUSTAR&#10;-------------------------&#10;&#10;□ PASSO 5.1: Testar cadastro de candidato&#10;   • Executar o programa&#10;   • Cadastrar um novo candidato pelo menu&#10;   • Verificar no banco se foi salvo:&#10;     SELECT * FROM candidatos;&#10;&#10;□ PASSO 5.2: Testar listagem&#10;   • Listar candidatos pelo menu&#10;   • Verificar se mostra os do banco&#10;&#10;□ PASSO 5.3: Testar cadastro de empresa&#10;   Similar ao candidato&#10;&#10;□ PASSO 5.4: Testar vagas&#10;   • Cadastrar vaga vinculada a uma empresa existente&#10;   • Verificar competências associadas&#10;&#10;================================================================================&#10;6. COMO TESTAR A INTEGRAÇÃO&#10;================================================================================&#10;&#10;TESTE 1: Conexão básica&#10;------------------------&#10;Criar arquivo TesteConexao.groovy:&#10;```&#10;Connection conn = DatabaseConnection.getConnection()&#10;println &quot;Conectado! Versão: &quot; + conn.metaData.databaseProductVersion&#10;DatabaseConnection.closeConnection(conn)&#10;```&#10;&#10;TESTE 2: Inserir e buscar candidato&#10;------------------------------------&#10;```&#10;CandidatoDAO dao = new CandidatoDAO()&#10;Candidato c = new Candidato(&quot;Teste&quot;, &quot;teste@email.com&quot;, ...)&#10;dao.inserir(c)&#10;List&lt;Candidato&gt; todos = dao.listar()&#10;todos.each { println it.nome }&#10;```&#10;&#10;TESTE 3: Programa completo&#10;---------------------------&#10;• Executar Main.groovy&#10;• Cadastrar novo candidato&#10;• Fechar o programa&#10;• Executar novamente&#10;• Verificar se o candidato ainda está lá (persistência!)&#10;&#10;VERIFICAÇÃO NO BANCO:&#10;---------------------&#10;Abrir terminal PostgreSQL ou pgAdmin:&#10;```&#10;psql -U postgres -d linketinder&#10;&#10;SELECT * FROM candidatos;&#10;SELECT * FROM empresas;&#10;SELECT * FROM vagas;&#10;SELECT * FROM competencias;&#10;```&#10;&#10;================================================================================&#10;7. ERROS COMUNS E SOLUÇÕES&#10;================================================================================&#10;&#10;ERRO 1: &quot;No suitable driver found&quot;&#10;-----------------------------------&#10;CAUSA: Biblioteca PostgreSQL JDBC não foi baixada&#10;SOLUÇÃO:&#10;• Verificar build.gradle tem: implementation 'org.postgresql:postgresql:42.7.1'&#10;• Executar: gradle clean build&#10;• Recarregar projeto na IDE&#10;&#10;ERRO 2: &quot;Connection refused&quot;&#10;-----------------------------&#10;CAUSA: PostgreSQL não está rodando OU porta/host errado&#10;SOLUÇÃO:&#10;• Verificar se PostgreSQL está rodando&#10;• No Mac: brew services list&#10;• Verificar URL: jdbc:postgresql://localhost:5432/linketinder&#10;• Verificar firewall&#10;&#10;ERRO 3: &quot;Password authentication failed&quot;&#10;-----------------------------------------&#10;CAUSA: Senha incorreta em DatabaseConnection&#10;SOLUÇÃO:&#10;• Confirmar senha do usuário postgres&#10;• Editar DatabaseConnection.groovy&#10;• Trocar PASSWORD = &quot;sua_senha&quot; pela senha correta&#10;&#10;ERRO 4: &quot;Relation 'candidatos' does not exist&quot;&#10;-----------------------------------------------&#10;CAUSA: Tabelas não foram criadas no banco&#10;SOLUÇÃO:&#10;• Executar o script LinkeTinder.sql no PostgreSQL&#10;• Verificar se conectou no banco correto: \c linketinder&#10;&#10;ERRO 5: &quot;Column 'id' is null&quot;&#10;------------------------------&#10;CAUSA: Tentou salvar objeto sem ID ou campo obrigatório faltando&#10;SOLUÇÃO:&#10;• ID deve ser gerado pelo banco (SERIAL)&#10;• Usar Statement.RETURN_GENERATED_KEYS para pegar ID&#10;• Verificar todos os campos obrigatórios do INSERT&#10;&#10;ERRO 6: NullPointerException ao listar&#10;---------------------------------------&#10;CAUSA: Tentou acessar propriedade de objeto null&#10;SOLUÇÃO:&#10;• Verificar se ResultSet tem dados: if (rs.next())&#10;• Verificar se lista está vazia antes de acessar: if (!lista.isEmpty())&#10;• Adicionar verificações null&#10;&#10;ERRO 7: &quot;Too many connections&quot;&#10;-------------------------------&#10;CAUSA: Não fechou conexões anteriores&#10;SOLUÇÃO:&#10;• SEMPRE usar try-finally&#10;• SEMPRE chamar DatabaseConnection.closeConnection(conn)&#10;• Considerar usar Connection Pool no futuro&#10;&#10;================================================================================&#10;RESUMO DAS MUDANÇAS&#10;================================================================================&#10;&#10;ARQUIVOS NOVOS:&#10;✓ src/main/groovy/com/linketinder/database/DatabaseConnection.groovy&#10;✓ src/main/groovy/com/linketinder/dao/CandidatoDAO.groovy&#10;✓ src/main/groovy/com/linketinder/dao/EmpresaDAO.groovy&#10;✓ src/main/groovy/com/linketinder/dao/VagaDAO.groovy&#10;✓ src/main/groovy/com/linketinder/dao/CompetenciaDAO.groovy (opcional)&#10;&#10;ARQUIVOS MODIFICADOS:&#10;✓ build.gradle (adicionar dependência PostgreSQL)&#10;✓ src/main/groovy/com/linketinder/model/Candidato.groovy&#10;✓ src/main/groovy/com/linketinder/model/Empresa.groovy&#10;✓ src/main/groovy/com/linketinder/model/Vaga.groovy&#10;✓ src/main/groovy/com/linketinder/database/Database.groovy&#10;&#10;ARQUIVOS NÃO MODIFICADOS:&#10;✓ src/main/groovy/com/linketinder/view/Menu.groovy (mantém a mesma interface)&#10;✓ src/main/groovy/com/linketinder/Main.groovy (mantém o mesmo)&#10;✓ Testes unitários (por enquanto)&#10;&#10;================================================================================&#10;PRÓXIMOS PASSOS (APÓS JDBC FUNCIONAR)&#10;================================================================================&#10;&#10;1. Implementar sistema de curtidas no banco (tabela 'curtidas')&#10;2. Criar testes unitários com Spock para os DAOs&#10;3. Adicionar validações de dados&#10;4. Implementar busca por competências&#10;5. Melhorar tratamento de erros&#10;6. Adicionar logs&#10;7. Considerar usar Connection Pool para performance&#10;&#10;================================================================================&#10;GLOSSÁRIO DE TERMOS&#10;================================================================================&#10;&#10;JDBC: Java Database Connectivity - API para conectar Java com bancos de dados&#10;&#10;DAO: Data Access Object - Padrão que separa acesso a dados da lógica de negócio&#10;&#10;Connection: Objeto que representa conexão ativa com o banco de dados&#10;&#10;PreparedStatement: Comando SQL preparado de forma segura (previne SQL Injection)&#10;&#10;ResultSet: Conjunto de resultados de uma query SELECT (como uma tabela)&#10;&#10;SQL Injection: Ataque de segurança onde código malicioso é inserido via input&#10;&#10;CRUD: Create, Read, Update, Delete - Operações básicas em banco de dados&#10;&#10;ORM: Object-Relational Mapping - Mapeia objetos para tabelas (ex: Hibernate)&#10;&#10;Transaction: Conjunto de operações que devem todas ter sucesso ou falhar juntas&#10;&#10;Foreign Key: Chave estrangeira - liga uma tabela a outra&#10;&#10;Primary Key: Chave primária - identificador único de cada linha&#10;&#10;SERIAL: Tipo PostgreSQL que gera IDs automaticamente (auto-increment)&#10;&#10;================================================================================&#10;DICAS FINAIS&#10;================================================================================&#10;&#10;1. SEMPRE feche as conexões! Use try-finally ou try-with-resources&#10;&#10;2. Use PreparedStatement, nunca concatene strings SQL (segurança!)&#10;&#10;3. Trate exceções de forma apropriada, não apenas printStackTrace()&#10;&#10;4. Faça backup do banco antes de testar operações de DELETE&#10;&#10;5. Use transações para operações que precisam ser atômicas&#10;&#10;6. Teste cada DAO isoladamente antes de integrar tudo&#10;&#10;7. Mantenha a senha do banco em arquivo de configuração (não no código!)&#10;&#10;8. Use logs para debug (System.out.println é temporário)&#10;&#10;9. Leia a documentação do PostgreSQL JDBC Driver&#10;&#10;10. Peça ajuda quando travar! É normal ter dúvidas no início&#10;&#10;================================================================================&#10;BOA SORTE COM A INTEGRAÇÃO JDBC!&#10;================================================================================" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>